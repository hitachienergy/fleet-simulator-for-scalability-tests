import csv
import os
import subprocess
from datetime import datetime
from typing import Dict, List

import docker
from docker.errors import APIError
from docker.models.containers import Container

PERIOD = 10  # stats gathering period in seconds
FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"  # datetime format used in the python docker sdk

client = docker.from_env()


def bytes_to_megabytes(bytes):
    return str(round(bytes / 1048576, 2)) + "MB"


# def extract_measurement(s: str) -> Tuple(int, str):
#     """Splits an input byte measurement into its components, the number and the unit of measure.

#     Args:
#         s (str): the input string measurement.

#     Raises:
#         ValueError: if the unit part of the input string is not one of b, kb, mb, gb, ib, kib, mib, gib.

#     Returns:
#         Tuple(int, str): the two components of the input measurement.
#     """
#     match = re.match(r"(\d+(\.\d+)?)(\s*)([a-zA-Z]+)", s)
#     if match:
#         value, _, _, unit = match.groups()
#         return round(float(value)), unit
#     raise ValueError()

# def convert_to_bytes(value) -> str:
#     value, unit = extract_measurement(value)
#     try:
#         return value * units[unit.lower()]
#     except KeyError:
#         raise ValueError(
#             f"Invalid unit: {unit}. Valid units are {', '.join(units.keys())}"
#         )


def save_stats(output_folder: str):
    """Reads docker containers statistics and saves them into a .csv file.

    Args:
        output_folder (str): the folder where the .csv file will be saved.
    """
    logs = get_stats_2()

    if len(logs) == 0:
        return

    output_file = os.path.join(output_folder, "docker_stats.csv")
    add_header = False
    if not os.path.exists(output_file):
        add_header = True

    keys = logs[0].keys()

    with open(output_file, "a+") as f:
        dict_writer = csv.DictWriter(f, keys)
        if add_header:
            dict_writer.writeheader()
        dict_writer.writerows(logs)


def get_stats() -> List[Dict[str, str]]:
    """Executes the "docker stats" command and parses the table into python data structures.

    Returns:
        List[Dict[str, str]]: a list of dictionaries. Each dict is a separate docker container. Each value in the dict corresponds to one specific HW statistic (cpu usage, mem usage, network usage ...).
    """
    str_datetime = datetime.now().isoformat()
    result = subprocess.run(
        [
            "docker",
            "stats",
            "--no-stream",
            "--format",
            "{{.ID}},{{.Name}},{{.CPUPerc}},{{.MemUsage}},{{.NetIO}},{{.BlockIO}},{{.PIDs}}",
        ],
        stdout=subprocess.PIPE,
    )
    output = result.stdout.decode("utf-8")

    stats = []
    for row in output.split("\n"):
        if row == "":
            continue
        id, container, cpu, mem_usage, net_io, block_io, pid = row.split(",")
        if container == "--":
            continue
        stats.append(
            {
                "datetime": str_datetime,
                "id": id,
                "container": container,
                "pid": pid,
                "cpu_perc": cpu[:-1],
                "mem_usage": mem_usage.split("/")[0].strip(),
                "mem_usage_lim": mem_usage.split("/")[1].strip(),
                "net_i": net_io.split("/")[0].strip(),
                "net_o": net_io.split("/")[1].strip(),
                "block_i": block_io.split("/")[0].strip(),
                "block_o": block_io.split("/")[1].strip(),
            }
        )
    return stats


def get_stats_2() -> List[Dict[str, str]]:
    """Parses docker containers stats generated by the Python Docker SDK.

    We follow the golang based implementation:
    https://github.com/moby/moby/blob/eb131c5383db8cac633919f82abad86c99bffbe5/cli/command/container/stats_helpers.go#L175

    Returns:
        List[Dict[str, str]]: a list of dictionaries. Each dict is a separate docker container. Each value in the dict corresponds to one specific HW statistic (cpu usage, mem usage, network usage ...).
    """

    output = []
    for container in client.containers.list():
        if not isinstance(container, Container):
            continue

        try:
            stats = container.stats(decode=None, stream=False)
        except:
            continue

        # FIX: Rarely, python based docker stats generate a timestamp similar to 0001-01-01T00:00:00Z
        if stats["read"].startswith("0001"):
            continue

        net_i, net_o = calculate_net_io(stats)
        block_i, block_o = calculate_block_io(stats)

        mem_usage = mem_limit = 0
        if "usage" in stats["memory_stats"]:
            mem_usage = stats["memory_stats"]["usage"]
        if "limit" in stats["memory_stats"]:
            mem_limit = stats["memory_stats"]["limit"]

        output.append(
            {
                "datetime": stats["read"],
                "id": stats["id"][:12],
                "container": stats["name"][1:],
                "cpu_perc": calculate_cpu_perc(stats),
                "mem_usage": bytes_to_megabytes(mem_usage),
                "mem_usage_lim": bytes_to_megabytes(mem_limit),
                "net_i": bytes_to_megabytes(net_i),
                "net_o": bytes_to_megabytes(net_o),
                "block_i": bytes_to_megabytes(block_i),
                "block_o": bytes_to_megabytes(block_o),
            }
        )

    return output


def calculate_cpu_perc(stats: dict):
    if "system_cpu_usage" not in stats["cpu_stats"]:
        return 0
    if "system_cpu_usage" not in stats["precpu_stats"]:
        return 0

    cpu_perc = 0

    cpu_delta = (
        stats["cpu_stats"]["cpu_usage"]["total_usage"]
        - stats["precpu_stats"]["cpu_usage"]["total_usage"]
    )
    system_delta = (
        stats["cpu_stats"]["system_cpu_usage"]
        - stats["precpu_stats"]["system_cpu_usage"]
    )
    num_cpus = stats["cpu_stats"]["online_cpus"]

    if system_delta > 0 and cpu_delta > 0:
        cpu_perc = (cpu_delta / system_delta) * (num_cpus * 100)

    return round(cpu_perc, 2)


def calculate_net_io(stats):
    if "networks" not in stats:
        return 0, 0

    rx, tx = 0, 0
    for _, net_stats in stats["networks"].items():
        rx += net_stats["rx_bytes"]
        tx += net_stats["tx_bytes"]
    return rx, tx


def calculate_block_io(stats):
    if not stats["blkio_stats"]["io_service_bytes_recursive"]:
        return 0, 0

    bread, bwrite = 0, 0
    for block_stats in stats["blkio_stats"]["io_service_bytes_recursive"]:
        if block_stats["op"].lower() == "read":
            bread += block_stats["value"]
        elif block_stats["op"].lower() == "write":
            bwrite += block_stats["value"]
    return bread, bwrite


if __name__ == "__main__":
    stats_1 = get_stats()
    stats_2 = get_stats_2()

    for c1 in stats_1:
        c2 = list(filter(lambda y: y["container"] == c1["container"], stats_2))[0]
        if not len(c2):
            continue
        print(c1["container"])
        for k, v in c1.items():
            if not k in c2:
                continue
            print(f"\t{k} - {v}, {c2[k]}")
        print("=" * 10)
